---
title: "Visualizing and Comparing Categorical Variables"
format:  
  revealjs: 
    theme: [default, style.scss]
execute:
  echo: true
editor: source
---

```{r}
#| include: false
#| label: load-package-set-python-directory

library(reticulate)
```

```{python}
#| include: false
#| label: import-packages

import numpy as np
import pandas as pd
```

# The story so far...

## Getting and Prepping Data

```{python}
#| code-line-numbers: false
#| label: read-data

import pandas as pd

df = pd.read_csv("data/titanic.csv")
```

</br>

```{python}
#| code-line-numbers: false
#| label: changing-data-type

df["Pclass"] = df["Pclass"].astype("category")
df["Survived"] = df["Survived"].astype("category")
```

## Thinking About Variable Types

::: {.small}
```{r}
#| echo: false
#| label: data-frame-table

knitr::kable(head(py$df))
```
:::


## Accessing Rows and Columns

::::: columns
::: {.column width="50%"}
```{python}
#| label: iloc
#| code-line-numbers: false

df.iloc[5,]
```
:::

::: {.column width="50%"}
```{python}
#| code-line-numbers: false
#| label: accessing-column

df["Name"]
```
:::
:::::

## Quick Summary of Quantitative Variables

::: {.midi}
```{python}
#| code-line-numbers: false
#| label: summarizing-data

df.describe()
```
:::

## Summarizing Categorical Variables

The list of percents for each category is called the **distribution** of the variable.

::: {.midi}
```{python}
#| code-line-numbers: false
#| label: counts-and-proportions-of-different-classes

df["Pclass"].value_counts()
df["Pclass"].value_counts(normalize = True)
```
:::

# Visualizing One Categorical Variable

## The Grammar of Graphics

The *Grammar of Graphics* (GoG) is a framework for creating data visualizations.

::: columns
::: {.column width="40%"}
::: {.small}
A visualization consists of:

-   The **aesthetic**: Which *variables* are dictating which *plot elements*.

-   The **geometry**: What *shape* of plot you are making.

-   The **theme**: Other choices about the appearance.
:::
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
![](images/02-ggplot-layers.png){fig-alt="A picture demonstrating the central idea of the grammar of graphics, that a visualization is comprised of layers. Each layer is displayed as a 3-D square in a different color with text written next to it. The first layer is the data, followed by the aesthetics, then the geometries, then facets, then statistics, then coordinates, then finally a theme."}
:::
:::

## Penguins!

```{python}
#| label: load-penguins-data
#| code-line-numbers: false

from palmerpenguins import load_penguins

penguins = load_penguins()
```

::: columns
::: {.column width="40%"}
![](images/02-adelie-penguin.jpg){fig-alt="A picture of an Adelie penguin. The penguin looks like a standard penguin, but has a very short bill."}
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
![](images/02-chinstrap-penguin.jpeg){fig-alt="A picture of a Chinstrap penguin. You can tell the penguin is a Chinstrap penguin because it has a small black line underneath its jawline that looks like a strap."}
:::
:::


## Example `plotnine` Code

::: midi
```{python}
#| eval: false
#| label: code-for-boxplot
#| code-line-numbers: false

from plotnine import ggplot, geom_point, aes, geom_boxplot, labs

(
  ggplot(penguins, mapping = aes(x = "species", 
                                 y = "bill_length_mm", 
                                 fill = "sex")
        ) +
  geom_boxplot() + 
  labs(x = "Species", 
       y = "Bill Length (mm)", 
       fill = "Penguin Sex")
)
```
:::

. . .

::: {.callout-tip}
# Take 90-seconds

Draw what plot you think this code would produce.
:::

## Revealed!


```{python}
#| echo: false
#| label: boxplot
#| fig-align: center

from plotnine import ggplot, geom_point, aes, geom_boxplot, labs

plot = (
  ggplot(penguins, mapping = aes(x = "species", 
                                 y = "bill_length_mm", 
                                 fill = "sex")
        ) +
  geom_boxplot() + 
  labs(x = "Species", 
       y = "Bill Length (mm)", 
       fill = "Penguin Sex")
)

plot.show()
```

## Aesthetics & Geometries

::: columns
::: {.column width="50%"}
The Grammar of Graphics framework map variables from the data to **aesthetics**
in the plot. 

</br>

**What aesthetics are variables mapped onto in the plot?**
:::

::: {.column width="50%"}
::: {.fragment}
The GoG also uses different geometries to represent the data. 

</br>

**What shape(s) are used to represent the data / observations in the plot?**
:::
:::
:::

## plotnine

The `plotnine` library implements the *grammar of graphics* in Python.

-   The `aes()` function is the place to map variables to plot aesthetics.
    -   `x`, `y`, and `fill` are three possible aesthetics that can be specified
-   A variety of `geom_XXX()` functions allow for different plotting shapes (e.g. boxplot, histogram, etc.)
    -   Aesthetics can differ based on the `geom` you choose!

## Themes

::: midi
```{python}
#| code-fold: true
#| code-line-numbers: false
#| label: boxplot-theme-classic-code
#| eval: false

from plotnine import theme_bw

(
  ggplot(penguins, aes(x = "species", 
                       y = "bill_length_mm", 
                       fill = "sex")
                       ) + 
  geom_boxplot() + 
   labs(x = "Species", 
        y = "Bill Length (mm)", 
        fill = "Penguin Sex") +
  theme_bw()
)
```
:::

```{python}
#| label: boxplot-theme-classic-plot
#| echo: false
#| fig-align: center

from plotnine import theme_bw

plot = (
  ggplot(penguins, aes(x = "species", 
                       y = "bill_length_mm", 
                       fill = "sex")
                       ) + 
  geom_boxplot() + 
   labs(x = "Species", 
        y = "Bill Length (mm)", 
        fill = "Penguin Sex") +
  theme_bw()
)

plot.show()
```


## Check-In

What are the *aesthetics* and *geometry* in the cartoon plot below?

![An XKCD comic](https://imgs.xkcd.com/comics/escalators.png){fig-alt="A graph showing the 'urge to try running up the down escalator' (y-axis) against age (x-axis). The y-axis ranges from weak to strong, and the x-axis spans ages 0 to 24. Two lines are plotted: 'What I was supposed to feel,' which peaks at age 10 and declines steeply thereafter; and 'What I've actually felt,' which remains high and relatively flat after age 10. Stick figures are drawn on the graph to illustrate the difference, with labels pointing to key points."}

## Bar Plots

To visualize the **distribution** of a categorical variable, we should use a **bar plot**.

::: small
```{python}
#| code-fold: true
#| code-line-numbers: false
#| label: bar-plot-code
#| eval: false

from plotnine import *

(
  ggplot(data = df, mapping = aes(x = "Pclass")) + 
  geom_bar() + 
  labs(x = "Class of Passenger on Titanic") +
  theme_bw()
)
```
:::

```{python}
#| label: bar-plot
#| echo: false
#| fig-align: center

from plotnine import *

plot = (
  ggplot(data = df, mapping = aes(x = "Pclass")) + 
  geom_bar() + 
  labs(x = "Class of Passenger on Titanic") +
  theme_bw()
)

plot.show()
```

## Calculating Percents

```{python}
#| code-line-numbers: false
#| label: df-of-proportions

pclass_dist = (
  df['Pclass']
  .value_counts(normalize = True)
  .reset_index()
  )
  
pclass_dist
```

. . .

::: {.callout-tip}
# Why reset the index? What does that do?
:::

## Percents on Plots

::: small
```{python}
#| code-fold: true
#| code-line-numbers: false
#| label: proportion-bar-plot-code
#| eval: false

(
  ggplot(data = pclass_dist, 
         mapping = aes(x = "Pclass", y = "proportion")) + 
  geom_col() + ### notice this change to a column plot!
  labs(x = "Class of Passenger on Titanic") +
  theme_bw()
)
```
:::

:::::::: columns
::: {.column width="55%"}
```{python}
#| label: proportion-bar-plot
#| echo: false

plot = (
  ggplot(data = pclass_dist, 
         mapping = aes(x = "Pclass", y = "proportion")) + 
  geom_col() + ### notice this change to a column plot!
  labs(x = "Class of Passenger on Titanic") +
  theme_bw()
)

plot.show()
```
:::

::: {.column width="5%"}
:::

::::: {.column width="40%"}
:::: fragment
::: midi
::: callout-tip
Technically, you could still use `geom_bar()`, but you would need to specify
that you didn't want it to use `stat = "count"` (the default). You've already
calculated the proportions, so you would use `geom_bar(stat = "identity")`.
:::
:::
::::
:::::
::::::::

# Visualizing Two Categorical Variables

## Option 1: Stacked Bar Plot

::: small
```{python}
#| code-fold: true
#| code-line-numbers: false
#| label: stacked-bar-plot-code
#| eval: false

(
  ggplot(data = df, mapping = aes(x = "Pclass", fill = "Sex")) + 
  geom_bar(position = "stack") + 
  labs(x = "Class of Passenger on Titanic", 
       fill = "Sex of Passenger") +
  theme_bw()
)
```
:::

```{python}
#| label: stacked-bar-plot
#| echo: false
#| fig-align: center

plot = (
  ggplot(data = df, mapping = aes(x = "Pclass", fill = "Sex")) + 
  geom_bar(position = "stack") + 
  labs(x = "Class of Passenger on Titanic", 
       fill = "Sex of Passenger") +
  theme_bw()
)

plot.show()
```

## Option 1: Stacked Bar Plot

> What are some pros and cons of the stacked bar plot?

:::::::::: columns
::::: {.column width="45%"}
:::: fragment
**Pros**

::: midi
-   We can still see the total counts in each class
-   We can easily compare the `male` counts in each class, since those bars are on the bottom.
:::
::::
:::::

::: {.column width="5%"}
:::

::::: {.column width="45%"}
:::: fragment
**Cons**

::: midi
-   It is hard to compare the `female` counts, since those bars are stacked on top.
-   It is hard to estimate the *distributions*.
:::
::::
:::::
::::::::::

## Option 2: Side-by-Side Bar Plot

::: small
```{python}
#| code-fold: true
#| code-line-numbers: false
#| label: side-by-side-barplot-code
#| eval: false

(
  ggplot(data = df, mapping = aes(x = "Pclass", fill = "Sex")) + 
  geom_bar(position = "dodge") + 
  labs(x = "Class of Passenger on Titanic", 
       fill = "Sex of Passenger") +
  theme_bw()
)
```
:::

```{python}
#| label: side-by-side-barplot
#| echo: false
#| fig-align: center

plot = (
  ggplot(data = df, mapping = aes(x = "Pclass", fill = "Sex")) + 
  geom_bar(position = "dodge") + 
  labs(x = "Class of Passenger on Titanic", 
       fill = "Sex of Passenger") +
  theme_bw()
)

plot.show()
```

## Option 2: Side-by-side Bar Plot

> What are some pros and cons of the side-by-side bar plot?

:::::::::: columns
::::: {.column width="45%"}
:::: fragment
**Pros**

::: midi
-   We can easily compare the `female` counts in each class.

-   We can easily compare the `male` counts in each class.

-   We can easily see counts of each within each class.
:::
::::
:::::

::: {.column width="5%"}
:::

::::: {.column width="45%"}
:::: fragment
**Cons**

::: midi
-   It is hard to see *total* counts in each class.

-   It is hard to estimate the *distributions*.
:::
::::
:::::
::::::::::

## Option 3: Stacked Percentage Bar Plot

::: small
```{python}
#| code-fold: true
#| code-line-numbers: false
#| label: stacked-percentage-barplot-code
#| eval: false

(
  ggplot(data = df, mapping = aes(x = "Pclass", fill = "Sex")) + 
  geom_bar(position = "fill") +
  labs(x = "Class of Passenger on Titanic", 
       fill = "Sex of Passenger") +
  theme_bw()
)
```
:::

```{python}
#| label: stacked-percentage-barplot
#| echo: false
#| fig-align: center

plot = (
  ggplot(data = df, mapping = aes(x = "Pclass", fill = "Sex")) + 
  geom_bar(position = "fill") + 
  labs(x = "Class of Passenger on Titanic", 
       fill = "Sex of Passenger") +
  theme_bw()
)

plot.show()
```

## Option 3: Stacked Percentage Bar Plot

> What are some pros and cons of the stacked percentage bar plot?

:::::::::: columns
::::: {.column width="60%"}
:::: fragment
**Pros**

::: midi
-   This is the **best** way to compare sex balance across classes!

-   This is the option I use the most, because it can answer "Are you more likely to find \_\_\_\_\_\_ in \_\_\_\_\_\_ ?" type questions.
:::
::::
:::::

::: {.column width="5%"}
:::

::::: {.column width="35%"}
:::: fragment
**Cons**

::: midi
-   We can no longer see **any** counts!
:::
::::
:::::
::::::::::

## Activity 1.2

::::::: midi
Choose one of the plots from lecture so far and "upgrade" it.

:::::: columns
::: {.column width="60%"}
You can do this by:

-   Finding and using a different `theme`

-   Trying different variables

-   Trying a different *geometries*

-   Using `+ scale_fill_manual()` to change the colors being used
:::

:::: {.column width="40%"}
::: callout-tip
-   You will need to use documentation of `plotnine` and online resources!

-   Check out <https://www.data-to-viz.com/> for ideas and example code.

-   Ask GenAI questions like, "What do I add to a plotnine bar plot to change the colors?" *(But of course, make sure you understand the code you use!)*
:::
::::
::::::
:::::::

# Joint distributions

## Two Categorical Variables

```{python}
#| code-line-numbers: false
#| label: counts-for-two-categorical-variables

df[["Pclass", "Sex"]].value_counts()
```

. . .

</br>
</br>

But this is a little hard to read...

## Two-way Table

```{python}
#| output-location: column
#| code-line-numbers: false
#| label: pivoting-table-of-counts

(
  df[["Pclass", "Sex"]]
  .value_counts()
  .unstack()
  )
```

</br>

::: callout-tip
# Pivot Table

Essentially `unstack()` has pivoted the `sex` column from **long format** (where the values are included in one column) to **wide format** where each value has its own column.
:::

## Two-way Table - Percents

```{python}
#| code-line-numbers: false
#| label: pivoted-table-of-percents

(
  df[["Pclass", "Sex"]]
  .value_counts(normalize = True)
  .unstack()
  )
```

</br>

All of these values should sum to 1, aka, 100%!

## Switching Variable Order

**What cross-tabulation would you expect if we changed the order of the variables? In other words, what would happen if `"Sex"` came first and `"Pclass"` came second?**

. . .

```{python}
#| code-line-numbers: false
#| label: changing-order-of-categorical-variables

(
  df[["Sex", "Pclass"]]
  .value_counts(normalize = True)
  .unstack()
  )
```

## Interpretation

We call this the ***joint distribution*** of the two variables.

```{python}
#| echo: false
#| label: joint-distribution-pclass-sex

( 
  df[["Pclass", "Sex"]]
  .value_counts(normalize = True)
  .unstack()
  )
  
# Add row totals
#table["Total"] = table.sum(axis = 1)

# Add column totals
#table.loc["Total"] = table.sum(axis = 0)
```

> Of all the passengers on the Titanic, 11% were female passengers riding in first class.

. . .

-   NOT "11% of all females on Titanic..."
-   NOT "11% of all first class passengers..."

## Conditional Distribution from Counts

We know that:

-   466 passengers identified as **female**

-   Of those 466 passengers, 144 **rode in first class**

. . .

So:

-   144 / 466 = 31% **of female identifying passengers** rode in first class

Here we ***conditioned on*** the passenger being female, and then looked at the ***conditional distribution*** of `Pclass`.

## Conditional Distribution from Percentages

We know that:

-   35.5% of all passengers identified as **female**

-   Of those 35.5% of passengers, 11% **rode in first class**

So:

-   0.11 / 0.355 = 31% **of female identifying passengers** rode in first class

## Swapping Variables

We know that:

-   323 passengers **rode in first class**

-   Of those 323 passengers, 144 **identified as female**

So:

-   144 / 323 = 44.6% **of first class passengers** identified as female

Here we ***conditioned on*** the passenger being in first class, and then looked at the ***conditional distribution*** of `Sex`.

## Which one to condition on?

This depends on the **research question** you are trying to answer.

. . .

> "What class did most female identifying passengers ride in?"

-\> Of all *female passengers*, what is the conditional distribution of *class*?

. . .

> "What was the gender breakdown of first class?"

-\> Of all *first class passengers*, what is the conditional distribution of *sex*?

## Calculating in Python

::: midi
When we study two variables, we call the individual one-variable distributions the **marginal distribution** of that variable.
:::

:::::: columns
::: {.column width="47%"}
```{python}
#| code-line-numbers: false
#| label: marginal-class

marginal_class = (
  df['Pclass']
  .value_counts(normalize = True)
  )
```

</br>

```{python}
#| code-line-numbers: false
marginal_class
```
:::

::: {.column width="3%"}
:::

::: {.column width="48%"}
```{python}
#| code-line-numbers: false
#| label: marginal-sex

marginal_sex = (
  df['Sex']
  .value_counts(normalize = True)
  )
```

</br>

```{python}
#| code-line-numbers: false
marginal_sex
```
:::
::::::

## Calculating in Python

::: midi
We need to divide the **joint distribution** (e.g. "11% of passengers were first class female") by the **marginal distribution** of the variable we want to **condition on** (e.g. 35.5% of passengers were female).
:::

```{python}
#| code-line-numbers: false
#| label: joint-to-marginal-sex

joint_class_sex = (
  df[["Pclass", "Sex"]]
  .value_counts(normalize = True)
  .unstack()
  )
  
joint_class_sex.divide(marginal_sex)
```

## Check-In

:::::: columns
::: {.column width="40%"}
```{python}
#| code-line-numbers: false
#| label: joint-to-marginal-sex-check-in-part-1

marginal_sex
```
:::

::: {.column width="5%"}
:::

::: {.column width="55%"}
```{python}
#| code-line-numbers: false
#| label: joint-to-marginal-sex-check-in-part-2

joint_class_sex
```
:::
::::::

</br>

:::::: columns
::: {.column width="65%"}
```{python}
#| code-line-numbers: false
#| label: joint-to-marginal-sex-check-in-part-3

joint_class_sex.divide(marginal_sex)
```
:::

::: {.column width="5%"}
:::

::: {.column width="30%"}
**How do you think `divide()` works?**
:::
::::::

## Check-In

Should the **rows** or **columns** add up to 100%? Why?

```{python}
#| echo: false

joint_class_sex.divide(marginal_sex)
```

## Conditional on Class

```{python}
#| code-line-numbers: false
#| label: joint-conditional-on-class

joint_class_sex = (
  df[["Sex", "Pclass"]]
  .value_counts(normalize = True)
  .unstack()
  )
  
joint_class_sex.divide(marginal_class)
```

## What if you get it backwards?

```{python}
#| code-line-numbers: false
#| label: joint-conditional-wrong-division

joint_class_sex = (
  df[["Pclass", "Sex"]]
  .value_counts(normalize = True)
  .unstack()
  )
  
joint_class_sex.divide(marginal_class)
```

## Which plot better answers:

> "Did women tend to ride in first class more than men?"

::::: columns
::: {.column width="50%"}
```{python}
#| code-fold: true
#| code-line-numbers: false
#| label: filled-bar-plot-question-code
#| eval: false

(
  ggplot(df, aes(x = "Pclass", fill = "Sex")) + 
  geom_bar(position = "fill") + 
  labs(x = "Class of Passenger on Titanic", 
       fill = "Sex of Passenger") +
  theme_bw()
)
```

```{python}
#| label: filled-bar-plot-question
#| echo: false

plot = (
  ggplot(df, aes(x = "Pclass", fill = "Sex")) + 
  geom_bar(position = "fill") + 
  labs(x = "Class of Passenger on Titanic", 
       fill = "Sex of Passenger") +
  theme_bw()
)

plot.show()
```
:::

::: {.column width="50%"}
```{python}
#| code-fold: true
#| code-line-numbers: false
#| label: filled-bar-plot-question-code-2
#| eval: false

(
  ggplot(df, aes(x = "Sex", fill = "Pclass)) + 
  geom_bar(position = "fill") + 
  labs(fill = "Class of Passenger on Titanic", 
       x = "Sex of Passenger") +
  theme_bw()
)
```

```{python}
#| label: filled-bar-plot-question-2
#| echo: false

plot = (
  ggplot(df, aes(x = "Sex", fill = "Pclass")) + 
  geom_bar(position = "fill") + 
  labs(fill = "Class of Passenger on Titanic", 
       x = "Sex of Passenger") +
  theme_bw()
)

plot.show()
```
:::
:::::

# Takeaways

## Takeaways

:::: midi
::: incremental
-   We use `plotnine` and the **grammar of graphics** to make visuals.

-   For two categorical variables, we might use a **stacked bar plot**, a **side-by-side bar plot**, or a **stacked percentage bar plot** - depending on what we are trying to show.

-   The **joint distribution** of two variables gives the percents in each subcategory.

-   The **marginal distribution** of a variable is its individual distribution.

-   The **conditional distribution** of a variable is its distribution among *only one category* of a different variable.

-   We calculate the **conditional distribution** by dividing the **joint** by the **marginal**.
:::
::::
